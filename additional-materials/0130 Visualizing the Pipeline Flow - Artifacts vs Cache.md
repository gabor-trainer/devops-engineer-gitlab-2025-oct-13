# Visualizing the Pipeline Flow - Artifacts vs. Cache

## The Key Difference

| Aspect          | **Artifacts**                                  | **Cache**                                                        |
| --------------- | ---------------------------------------------- | ---------------------------------------------------------------- |
| **Purpose**     | Pass data **between stages** in a pipeline     | Speed up builds by reusing **dependencies** across pipeline runs |
| **Direction**   | Flows **downstream** (build → test → deploy)   | Stored **externally** and shared across jobs/pipelines           |
| **Reliability** | **Guaranteed** to be available                 | **Best-effort** - may not exist on first run                     |
| **When to use** | Build outputs, test results, compiled binaries | `node_modules/`, `.m2/`, `vendor/` directories                   |

---

## Visual Flow Representation

### Pipeline with Artifacts (Downstream Flow)

```
┌─────────────┐
│   BUILD     │
│   Stage     │
│             │
│  Creates:   │
│  app.jar    │
└──────┬──────┘
       │ artifact
       │ (guaranteed)
       ▼
┌─────────────┐
│    TEST     │
│   Stage     │
│             │
│  Uses:      │
│  app.jar    │
└──────┬──────┘
       │ artifact
       │ (guaranteed)
       ▼
┌─────────────┐
│   DEPLOY    │
│   Stage     │
│             │
│  Uses:      │
│  app.jar    │
└─────────────┘
```

### Pipeline with Cache (External Storage)

```
                    ┌──────────────────┐
                    │  Cache Storage   │
                    │  (S3/Minio/etc)  │
                    │                  │
                    │  node_modules/   │
                    │  .m2/repository/ │
                    └──────────────────┘
                           ▲     │
                    pull   │     │  push
                  (if exists)    │ (if changed)
                           │     ▼
┌──────────────────────────────────────────────┐
│              Pipeline Run #1                  │
│                                              │
│  Job 1          Job 2          Job 3         │
│  ┌─────┐       ┌─────┐       ┌─────┐       │
│  │npm  │       │npm  │       │npm  │       │
│  │install│     │test │       │build│       │
│  └─────┘       └─────┘       └─────┘       │
│     ▲              ▲              ▲          │
│     └──────────────┴──────────────┘          │
│           (all reuse cache)                  │
└──────────────────────────────────────────────┘
```

---

## Practical Examples

### Example 1: Using Artifacts

```yaml
stages:
  - build
  - test
  - deploy

build-job:
  stage: build
  script:
    - mvn package
  artifacts:
    paths:
      - target/*.jar
    expire_in: 1 week  # Artifacts are temporary

test-job:
  stage: test
  script:
    - java -jar target/myapp.jar --test
  dependencies:
    - build-job  # Explicitly declare artifact dependency

deploy-job:
  stage: deploy
  script:
    - scp target/myapp.jar server:/apps/
  dependencies:
    - build-job
```

**What happens:** The `target/*.jar` file created in `build-job` is automatically available in `test-job` and `deploy-job`.

---

### Example 2: Using Cache

```yaml
build-job:
  stage: build
  cache:
    key: ${CI_COMMIT_REF_SLUG}  # Cache per branch
    paths:
      - node_modules/
  script:
    - npm install  # Only downloads new/changed packages
    - npm run build

test-job:
  stage: test
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull  # Only pull, don't push
  script:
    - npm test  # Reuses node_modules from cache
```

**What happens:** On the first run, `npm install` downloads all packages. On subsequent runs, cached `node_modules/` is restored, making the install much faster.

---

## Common Mistakes & Clarifications

### ❌ **Mistake 1: Using cache to pass build outputs**

```yaml
# DON'T DO THIS
build-job:
  cache:
    paths:
      - dist/  # Wrong! This is a build output
```

**Why it's wrong:** Cache is not guaranteed to exist. If the cache is cleared, your deploy job will fail.

**✅ Correct approach:** Use artifacts for build outputs.

---

### ❌ **Mistake 2: Using artifacts for dependencies**

```yaml
# INEFFICIENT
build-job:
  artifacts:
    paths:
      - node_modules/  # Wrong! This is huge and slows down pipeline
```

**Why it's wrong:** `node_modules/` can be hundreds of MB. Artifacts are uploaded/downloaded between every stage, adding significant time.

**✅ Correct approach:** Use cache for dependencies.

---

## Decision Tree

```
Do you need this data in a later stage?
│
├─ YES → Is this data generated by the pipeline?
│         │
│         ├─ YES (e.g., compiled code, test reports)
│         │   └─ Use ARTIFACTS
│         │
│         └─ NO (e.g., downloaded dependencies)
│             └─ Use CACHE
│
└─ NO → Don't store it
```

---

## Cache Keys: An Important Detail

Cache effectiveness depends on choosing the right **cache key**:

```yaml
# Cache per branch (changes cleared when switching branches)
cache:
  key: ${CI_COMMIT_REF_SLUG}

# Cache globally (shared across all branches)
cache:
  key: "global-cache"

# Cache per OS/version combination
cache:
  key: ${CI_JOB_NAME}-${CI_COMMIT_REF_SLUG}
```

**Rule of thumb:** Use branch-specific keys for most cases.

---

## Summary

| When you need...                      | Use           |
| ------------------------------------- | ------------- |
| To pass build outputs to later stages | **Artifacts** |
| To speed up dependency downloads      | **Cache**     |
| Guaranteed availability               | **Artifacts** |
| Best-effort optimization              | **Cache**     |
| Test reports, coverage data           | **Artifacts** |
| `node_modules/`, Maven `.m2/`         | **Cache**     |

---

## Further Reading

- [GitLab Docs: Artifacts](https://docs.gitlab.com/ee/ci/pipelines/job_artifacts.html)
- [GitLab Docs: Cache](https://docs.gitlab.com/ee/ci/caching/)
- [Best Practices: Caching Dependencies](https://docs.gitlab.com/ee/ci/caching/#common-use-cases-for-caches)